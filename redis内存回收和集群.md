### redis内存回收和集群

#### 内存回收

Redis的内存回收策略主要体现在两个方面：

- 删除到达过期时间的键对象
- 内存达到 maxmemory 后的淘汰机制

删除过期键对象

**1.定时过期**

每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

**2.惰性过期**

只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

**3.定期过期**

每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

Redis中同时使用了惰性过期和定期过期两种过期策略，即使过期时间到了，但是有部分并没有真正删除，等待惰性删除。

为什么有定期还要有惰性呢？其实很简单，比如10万个key就要过期了，Redis默认是100ms检查一波。如果他检查出10万个即将要清除，那他接下来的时间基本都是在干这些清空内存的事了，那肯定影响性能，所以他只会部分删除，剩下的等惰性

原文链接：https://blog.csdn.net/zlc3323/article/details/80836881



**为什么需要淘汰策略**

有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充也是redis在内存空间不足的时候，为了保证命中率，就会选择一定的数据淘汰策略

| **策略**        | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| noeviction      | 禁止驱逐数据，这也是默认策略                         |
| allkeys-lru     | 从数据集中挑选最近最少使用的数据淘汰                 |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| allkeys-random  | 从数据集中任意选择数据淘汰                           |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰。         |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰。   |
| volatile-lfu    | 从已设置过期时间的数据集挑选使用频率最低的数据淘汰。 |
| allkeys-lfu     | 从数据集中挑选使用频率最低的数据淘汰。               |



#### 热Key问题的危害

上面提到，所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。
那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。

简单总结三点

- 流量集中，达到物理网卡上限。
- 请求过多，导致服务宕机。
- DB 击穿，引起业务雪崩。

#### 热Key监控方法

| 方法            | 优点                                                         | 缺点                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 客户端          | 实现简单                                                     | 1.客户端代码造成入侵。2.内存泄露隐患。3.维护成本高。4.只能统计单个客户端 |
| 在Proxy(代理)层 | 代理是客户端和服务器桥梁.实现最方便最系统                    | 增加代理端的开发部署成本                                     |
| 服务端          | 实现简单 已有命令和工具<br/>1.monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina<br/>2.Redis自4.0起提供了hotkeys参数来方便用户进行实例级的热Key分析功，该参数能够返回所有Key的被访问次数，它的缺点同样为不可定制化输出报告，大量的信息会使你在分析结果时复杂度较大，另外，使用该方案的前提条件是将redis-server的maxmemory-policy参数设置为LFU。 | 1.该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能,只能短时间使用<br/>2.该参数在执行的时候，如果key比较多，执行起来比较慢<br/>3.只能统计单个redis节点 |
| 机器抓包评估    | 对于客户端和服务端无入侵和影响<br/>Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析 | 开发成本高，维护困难，有丢包可能性需要专业额运维团队开发，并增加了机器部署成本 |

#### 如何解决

| 方法                           |                                                              |
| ------------------------------ | ------------------------------------------------------------ |
| 拆分复杂数据结构               | 如果当前key额类型是一个二级数据结构,如hash类型如果元素数量较多，可以考虑将当前hash进行拆分,这样该热点key可以拆分为若干个新的key分布到不同的redis节点上,从而减经压力。 |
| 迁移热点key                    | 以 redis cluster为例,可以将热点key所在的solt单独迁移到一个新的redis节点上,但此操作会增加运维成本。 |
| 本地缓存加通知机制（二级缓存） | 可以将热点key放在业务端的本地缓存中,因为是业务端的本地内存中。处理能力要高出redis数十倍,但是当数据更新时,此种模式会造成各人业务端和redis数据一致,通常会使用发布订阅机制来解决类型问题 |



### 什么是bigkey？

bigkey就是redis key/value体系中的大value问题。根据数据类型的划分，bigkey体现在两点：

- 存储数据为string类型, value值长度过大；
- value为复合类型，包含元素个数过多。

在redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，这是一个理论值，实际使用时，我们可以通过运维给到的数据来综合衡量限制数，一般string类型控制在10KB以内，复合类型hash、 list,、set,和zset元素个数不超过5000个。

#### 查找bigkey方法



**bigkey危害**

| 危害**         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 内存空间不均匀 | 在集群模式中，由于bigkey的存在，会造成主机节点的内存不均匀，这样会不利于集群对内存的统一管理，存在丢失数据的隐患。 |
| 超时阻塞       | 由于redis单线程的特性，操作bigkey通常比较耗时，也就意味着阻塞redis可能性越大，这样会造成客户端阻塞或者引起故障切换。慢查询通常就会有它们的身影。 |
| 网络拥塞       | bigkey也就意味着每次获取要产生的网络流量较大。假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾。 |
| 阻塞删除       | 有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性，而且这个过期删除不会从主节点的慢查询发现（因为这个删除不是客户端产生的，是内部循环事件，可以从latency命令中获取或者从slave节点慢查询发现）。 |
| 迁移困难       | 当需要对bigkey进行迁移（例如Redis cluster的迁移slot），实际上是通过migrate命令来完成的，migrate实际上是通过dump + restore + del三个命令组合成原子命令完成，如果是bigkey，可能会使迁移失败，而且较慢的migrate会阻塞Redis。 |

bigkey的存在并不是完全致命的，如果这个bigkey存在但是几乎不被访问，那么只有内存空间不均匀的问题存在，相对于另外两个问题没有那么重要紧急，但是如果bigkey是一个热点key (频繁访问)，那么其带来的危害不可想象，所以在实际开发和运维时一定要密切关注bigkey的存在。



#### 发现bigkey

| 方法 |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

解决bigkey