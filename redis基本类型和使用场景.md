## redis 基础类型介绍

### Redis为什么这么快

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

### 基础类型及应用场景

#### String

#### hash

#### list

#### set

#### zset

#### bitmap(string) 位图 

#### geospatial 地图位置

#### hyperloglogs  基数统计

#### streams 流

#### 类型结构

|  类型  | 底层数据结构                                                 | 条件                                                         |
| :----: | ------------------------------------------------------------ | ------------------------------------------------------------ |
| String | SDS(简单字符串)                                              |                                                              |
|  hash  | ziplist (压缩列表)+hashtable (哈希表)                        | 1. list对象保存的所有字符串元素的长度都小于64字节                                                           2. list对象保存的元素数量小于512个，                       (两条件都满足使用压缩列表) |
|  list  | 3.0版本数据结构 ：ziplist (压缩列表)+linkedlist;                                                                                                                            3.2之后的版本 ：quicklist 可以认为quickList，是ziplist和linkedlist二者的结合 | 1. list对象保存的所有字符串元素的长度都小于64字节                                                           2. list对象保存的元素数量小于512个， |
|  set   | intset(整数集合)+hashtable                                   | 1.集合对象保存的所有元素都是整数值                         2. 集合对象保存的元素数量不超过 512 个                 (两条件都满足使用整数集合) |
|  zset  | skiplist(跳表)+dict 字典                                     | 1.有序集合保存的元素数量小于默认值128个              2.有序集合保存的所有元素的长度小于默认值64字节 (两条件都满足使用跳表) |



#### String(SDS(简单字符串))

##### **SDS的主要用途**

1.保存数据库中的字符串值

2.被用作缓冲区（buffer）:AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。

##### 为什么redis要重新实现字符串

1.**相比C语言字符串，使获取字符串长度时间复杂度降为O(1**）

   C语言字符串不记录自身长度，如果想获取自身长度必须遍历整个字符串，对每个字符进行计数，这个操作时间复杂度是O(n)。相比较而言，Redis程序只要访问SDS的len属性就可以直接获取到字符串长度，时间复杂度为O(1)，确保获取字符串长度不会成为Redis性能瓶颈，比如对字符串键反复执行strlen命令

**2. 杜绝缓冲区溢出**

C语言由于不记录自身长度，所以又带来一个问题：容易造成缓冲区溢出

**3. 减少修改字符串时带来的内存重分配次数**

​     **3.1空间预分配**

​		1.如果对SDS操作后，SDS的长度(len的值）小于1M,那么程序分配和len同样大小的未使用空间。

​        2.如果对SDS操作后，SDS的长度(len的值）大于等于1M,那么程序会分配1M的未使用空间。显然，通过使用空间预分配是可以有效         减少内存重分配次数的。

​     **3.2 惰性空间释放**

当面对字符串缩短操作：如果没有特殊操作，SDS的API需要缩短SDS保存的字符串，那么就需要使用内存重分配来回收多余的字节。

而当我们有了free属性，可以将多余字节调配给free记录下来，并等待将来使用！这也就为将来可能存在的增长操作提供了优化！

**4.二进制安全**

因为传统**C字符串**符合ASCII编码，这种编码的操作的特点就是：**遇零则止** 。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。

**扩展**:

字符串类型对应Redis底层三种数据结构，分表是int、raw和embstr。

（a）当Value是数字的时候，对应int

（b）当字符串长度比较短（长度不大于39字节）时，对应embstr

（c）当字符串长度比较长（长度大于39字节）时，对应raw

其中embstr和raw都是由SDS动态字符串构成的。唯一区别是：raw是分配内存的时候，redisobject和 sds 各分配一块内存，而embstr是redisobject和raw在一块儿内存中。

##### **场景**

1.1 一般的业务功能模块，比如购物车
设计key值的时候，尽量简洁、明了，比如xxx:cart:001表示某个用户的购物车信息

1.2 简单的字符缓存
项目中有些地方无法保存字符，可以存储到redis中，但是注意是否要设计加上过期时间和做好key的设计，否则redis莫名其妙的key会越来越多，难以维护

1.3 储存结构体或者对象
首先把对象转换成json字符串
然后set user:01 value
或者直接存储mset user:1:name a user:1:age 18
1.4 计数功能
点赞数或者文章浏览数等，可以方便通过incr来增加，decr来减少点赞或浏览次数（

NCR article:001        GET  article:001

1.5 各类场景下(单机或分布式)的标识号
比如我们常用的mysql是使用主键自增的，我们可以借助redis来帮我们生成唯一的主键，但是如果一次添加的数据比较多，会对redis有较大压力，可以一次从redis获取多个主键编号，然后使用incrby一次性增加具体的数目：incrby serialNo 1000

1.6 集群环境下的Session共享
使用spring session与redis完成session共享

1.7 redis实现分布式锁
redis使用String+lua实现分布式锁



#### hash (ziplist (压缩列表)+hashtable (哈希表))

存储多个无序的键值对，最大存储数量2^32-1(40亿左右)

**hash特点**

 1.节省内存空间

 2.减少key冲突

 3.取值减少性能消耗

**不适合场景**

 1.fieid不能单独设置过期时间

 2.需要考虑数据量分布的问题

##### **使用ziplist的优点**

```text
1. 为什么不直接用hastable：
相比hashtable，ziplist结构少了指针，大大的减少了
内存的使用，而内存对于redis来说弥足珍贵，

2. 为什么不用 linklist？
ziplist存储时内存分配是连续的，查询更快，这里的快只是
相对双端队列
```

##### **场景**

1.**购物车** 

常见命令 

| 命令                                    | 解释                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| hset                                    | 设置name对应的hash中的一个键值对，不存在则创建；存在则修改。 |
| hsetenx                                 | 设置那么中对应的键值对，是只能新建攸，亲。不能修改           |
| hmset                                   | hmset(name,mapping),批量设置                                 |
| hget和hmget                             | 获取1个key对应的值;hmget(name,key,args):获取多个个key对应的值 |
| hgetall                                 | 获取name中所有的键值对                                       |
| hlen                                    | 获取name的长度。                                             |
| hkeys                                   | 获取name中所有的个数。                                       |
| hvals                                   | 获取name中所有的value。                                      |
| hexists                                 | 判断key对应的值是否在name中，就是判断成员是否存在。          |
| hdel                                    | 删除指定的键值对。                                           |
| hincrby                                 | 自增自减函数，将key对应的值自增或者减1。复数为减             |
| hscan(name,cursor=0,match=None,count=1) | 这种读取方式对于大数据量的读取非常有用，分片的读取数据可以有效的防治一次性读入超量数据导致内存撑爆。 |
| hscan_iter                              | 使用yield封装hash创建生成器，实现分批获取数据                |



#### list(quicklist(ziplist (压缩列表)+linkedlist))

存储有序的字符串按照（插入顺序排序（从左至右）），元素可以重复。

##### 为什么要重写quicklist

- 双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。

- ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。

  

**quickList**

​    quickList是一个ziplist组成的双向链表。每个节点使用ziplist来保存数据

​	quickList就是一个标准的双向链表的配置，有head 有tail;

​    每一个节点是一个quicklistNode，包含prev和next指针。

​    每一个quicklistNode 包含 一个ziplist，*zp 压缩链表里存储键值。

​    所以quicklist是对ziplist进行一次封装，使用小块的ziplist来既保证了少使用内存，也保证了性能。

**场景命令**

1.添加操作：

rpush key value [value...]：从右边插入元素；

lpush key value [value...]：从左边插入元素；

linsert key before | after pivot value：向某个元素前/后插入元素，返回结果为当前列表长度；

2.查找操作：

lrange key start end：获取指定范围内的元素列表；如lrange key 0 -1，获取列表全部元素；

lindex key index：获取列表指定索引下标的元素，如lindex key -1，获取最后一个元素；

llen key：获取列表长度；

3.删除操作：

lpop key ：从列表左侧弹出元素；

rpop key ：从列表右侧弹出元素；

lrem key count value：lrem命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况;

count>0，从左到右，删除最多count个元素；

count<0，从右到左，删除最多count绝对值个元素；

count=0，删除所有元素。

ltrim key start end：按照索引范围修建列表，相当于切片操作。

4.修改操作：

lset key index newValue：修改指定下标的元素
5.阻塞操作：

阻塞式弹出：

blpop key [key ...] timeout

brpop key [key....] timeout

##### **场景**

1. 消息队列

　　list类型的lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能，故而可以用Redis的list类型实现简单的点对点的消息队列。不过我不推荐在实战中这么使用，因为现在已经有Kafka、NSQ、RabbitMQ等成熟的消息队列了，它们的功能已经很完善了，除非是为了更深入地理解消息队列，不然我觉得没必要去重复造轮子。

2. 排行榜

　　list类型的lrange命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等，下图是酷狗音乐“K歌擂台赛”的昨日打擂金曲排行榜，每日计算一次，存储在list类型中，接口访问时，通过page和size分页获取打擂金曲。（打个小广告，酷狗音乐“K歌擂台赛”每天都能产生一批优质翻唱作品，对普通人优质歌声有兴趣的朋友不妨来听听）。

但是，并不是所有的排行榜都能用list类型实现，只有定时计算的排行榜才适合使用list类型存储，与定时计算的排行榜相对应的是实时计算的排行榜，list类型不能支持实时计算的排行榜，之后在介绍有序集合sorted set的应用场景时会详细介绍实时计算的排行榜的实现。

3. 最新列表

　　list类型的lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。

　　但是，并不是所有的最新列表都能用list类型实现，因为对于频繁更新的列表，list类型的分页可能导致列表元素重复或漏掉，举个例子，当前列表里由表头到表尾依次有（E，D，C，B，A）五个元素，每页获取3个元素，用户第一次获取到（E，D，C）三个元素，然后表头新增了一个元素F，列表变成了（F，E，D，C，B，A），此时用户取第二页拿到（C，B，A），元素C重复了。只有不需要分页（比如每次都只取列表的前5个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用list类型实现。对于需要分页并且会频繁更新的列表，需用使用有序集合sorted set类型实现。另外，需要通过时间范围查找的最新列表，list类型也实现不了，也需要通过有序集合sorted set类型实现，如以成交时间范围作为条件来查询的订单列表。之后在介绍有序集合sorted set类型的应用场景时会详细介绍sorted set类型如何实现最新列表。

　　那么问题来了，对于排行榜和最新列表两种应用场景，list类型能做到的sorted set类型都能做到，list类型做不到的sorted set类型也能做到，那为什么还要使用list类型去实现排行榜或最新列表呢，直接用sorted set类型不是更好吗？原因是sorted set类型占用的内存容量是list类型的数倍之多（之后会在容量章节详细介绍），对于列表数量不多的情况，可以用sorted set类型来实现，比如上文中举例的打擂金曲排行榜，每天全国只有一份，两种数据类型的内存容量差距可以忽略不计，但是如果要实现某首歌曲的翻唱作品地区排行榜，数百万的歌曲，300多个地区，会产生数量庞大的榜单，或者数量更加庞大的朋友圈点赞列表，就需要慎重地考虑容量的问题了。

参考资料:https://www.cnblogs.com/pangzizhe/p/10674501.html



#### set(intset(整数集合)+hashtable)

set 存储string 类型的无序集合最大存储数量2^32-1（40亿左右）

**常见命令**

| 命令                                                         | 解释                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| sadd(name,values)                                            | name对应的集合中添加元素                                     |
| scard(name)                                                  | 获取name对应的集合中元素个数                                 |
| sdiff(keys, *args)                                           | 在第一个name对应的集合中且不在其他name对应的集合的元素集合   |
| sdiffstore(dest, keys, *args)                                | 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中 |
| sinter(keys, *args)                                          | 获取多一个name对应集合的并集                                 |
| sinterstore(dest, keys, *args)                               | 获取多一个name对应集合的并集，再讲其加入到dest对应的集合中   |
| sismember(name, value)                                       | 检查value是否是name对应的集合的成员                          |
| smembers(name)                                               | 获取name对应的集合的所有成员                                 |
| smove(src, dst, value)                                       | 将某个成员从一个集合中移动到另外一个集合                     |
| spop(name)                                                   | 从集合的右侧（尾部）移除一个成员，并将其返回                 |
| srandmember(name, numbers)                                   | 从name对应的集合中随机获取 numbers 个元素                    |
| srem(name, values)                                           | 在name对应的集合中删除某些值                                 |
| sunion(keys, *args)                                          | 获取多一个name对应的集合的并集                               |
| sunionstore(dest,keys, *args)                                | 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中 |
| sscan(name, cursor=0, match=None, count=None)<br/>sscan_iter(name, match=None, count=None) | 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大   |

##### 场景

**抽奖活动**

1. 把抽奖的数据放入set集合 ：sadd act:001  004
2. 开始抽奖2名中奖者，随机选择2个：srandmember act:001 2 或 spop act:001 2
3. 查看有多少用户参加了本次抽奖 ：smembers act:001

**点赞**

面试题目：朋友圈消息ID：008，微信点赞如何设计？ 张三用户ID 为userId:01
张三对消息ID008点赞啦       sadd zan:008  userId:01
张三取消了对消息008的点赞       srem zan:008  userId:01
检查用户是否点过赞       sismember zan:008  userId:01
获取消息ID008所有的点赞用户列表       smembers zan:008
消息ID008的点赞数计算       scard zan:008

**用户关注**

初始关注条件

a关注的人  sadd aCare 成龙 李连杰 周星驰 c
b关注的人      sadd bCare 周星驰 周润发 张国荣 c
c关注的人      sadd cCare 周星驰 李连杰 王祖贤
1）a和b共同关注的人      sinter aCare bCare , 计算结果为 {周星驰 ,c} 计算

2) 我关注的人也关注他(c老师)      sismember aCare c ;sismember cCare 周星驰 ;计算

3）我可能认识的人      SDIFF aCare bCare -> {周润发,张国荣}

原文链接：https://blog.csdn.net/qq_22701869/article/details/115609645



#### zset(skiplist(跳表)+dict 字典)

zset存储string 类型的有序集合最大存储数量2^32-1（40亿左右）

**常见命令**

| 命令             | 解释                               |
| ---------------- | ---------------------------------- |
| ZADD             | 添加多个元素到有序集合中           |
| ZINCRBY          | 为分数值加上增量                   |
| ZCARD            | 获取有序集合中的元素数量           |
| ZCOUNT           | 获取在分数区间内的元素数量         |
| ZLEXCOUNT        | 获取在指定区间内的元素数量         |
| ZRANGE           | 获取在指定区间内的元素（升序）     |
| ZREVRANGE        | 获取在指定区间内的元素（降序）     |
| ZSCORE 命令      | 获取元素的分数值                   |
| ZRANGEBYLEX      | 获取集合在指定范围内的元素         |
| ZRANGEBYSCORE    | 获取在指定分数区间内的元素         |
| ZREVRANGEBYSCORE | 获取在指定区间内的所有元素         |
| ZRANK            | 获取有序集合元素的排名             |
| ZREVRANK         | 获取有序集合元素的倒序排名         |
| ZINTERSTORE      | 保存多个有序集合的交集             |
| ZUNIONSTORE      | 保存多个有序集合的并集             |
| ZREM             | 删除有序集合中的多个元素           |
| ZREMRANGEBYLEX   | 删除有序集合在指定区间内的元素     |
| ZREMRANGEBYRANK  | 删除有序集合在指定排名区间内的元素 |
| ZREMRANGEBYSCORE | 删除有序集合在指定分数区间内的元素 |

##### 为什么redis的有序集合采用跳跃表而不是红黑树？

redis选择跳跃表而非红黑树作为有序集合实现方式的原因并非是基于并发上的考虑，因为redis是单线程的，选用跳跃表的原因仅仅是因为跳跃表的实现相较于红黑树更加简洁。

##### 什么是跳跃表：

(1). 跳跃表的每一层都是一条**有序的链表**.

(2). 跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)。

(3). 最底层的链表包含所有元素。

(4). 跳跃表是一种随机化的数据结构(通过抛硬币来决定层数)。

(5). 跳跃表的空间复杂度为 O(n)。

#### 场景

排行排

1）点击话题 zincrby topic:20191022 1 ；当前话题查看新增1

2)  展示今日前9排名的新闻 zrevrange  topic:20191022 0 20  withscores

3）统计近3日点击数据，并存放的新的集合 zunionstore topic:3day 3  topic:20191022  topic:20191021 topic:20191020

4) 展示近3日的排行前9名 zrevrange topic:20191022-20191020  0  9   withscores

#### bitmap(string) 位图 

 存储最大限制限制在 512 MB 

**常见命令**

| 命令     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| SETBIT   | 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)     |
| GETBIT   | 对 key 所储存的字符串值，获取指定偏移量上的位(bit)           |
| BITCOUNT | 计算给定字符串中，被设置为 1 的比特位的数量                  |
| BITPOS   | 返回位图中第一个值为 bit 的二进制位的位置                    |
| BITOP    | 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上 |
| BITFIELD | bitfield 有三个子指令，分别是 get/set/incrby，它们都可以对指定位片段进行读写，但是最多只能处理 64 个连续的位，如果超过 64 位，就得使用多个子指令，bitfield 可以一次执行多个子指令 |

##### 场景

1. 用户签到
2. 用户在线状态
3. 统计活跃用户
4. 各种状态值

#### geospatial( 地图位置)

**常用命令**

| 命令              | 解释                                                       |
| ----------------- | ---------------------------------------------------------- |
| GEOADD            | 将指定的地理空间位置(纬度、经度、名称)添加到指定的key中    |
| GEOPOS            | 从key里返回所有给定位置元素的位置(经度和纬度)              |
| GEODIST           | 返回两个给定位置之间的距离                                 |
| GEORADIUS         | 以给定的经纬度为中心，找出某一半径内的元素                 |
| GEOHASH           | 返回一个或多个位置元素的Geohash表示                        |
| GEORADIUSBYMEMBER | 找出位于指定范围内的元素，但是中心点由给定的位置元素来决定 |

##### 场景

微信位置共享，附近的人等地图功能。

#### hyperloglogs（基数统计）

**常用命令**

| 命令    | 解释                                      |
| ------- | ----------------------------------------- |
| Pfadd   | 将指定元素参数添加到HyperLogLog数据结构中 |
| Pfcount | 返回给定HyperLogLog的基数估算值           |
| PFMERGE | 将多个 HyperLogLog 合并为一个HyperLogLog  |

##### 场景

统计注册的IP数，每日访问数，每天在线人数，搜索词条数等类似场景

#### streams 流

Stream是在5.0版本之后才有的数据结构，是目前最复杂的数据结构。

| 命令       | 解释                                                         |
| ---------- | ------------------------------------------------------------ |
| xadd       | 向指定的stream添加元素。如果key不存在，就创建一个新的stream  |
| xlen       | 返回stream中的entry数量。如果key不存在，则返回0。对于长度为0的stream，Redis不会删除，因为可能存在关联的消费者组。 |
| XPENDING   | 通过消费者组捕获数据，但不是确认这些数据                     |
| xrange     | 查询指定范围内的entry                                        |
| XREADGROUP | XREADGROUP是XREAD的特殊版本，支持消费者组。                  |
| XREVRANGE  | 此命令与XRANGE唯一的区别是顺序相反。                         |
| XDEL       | 删除stream中的entry并返回删除的数量                          |
| XGROUP     | 创建与一个stream相关联的消费者组                             |
| XREAD      | 从一个或多个stream中读取数据，仅返回ID大于调用者报告的最后接收ID的条目 |
| XTRIM      | 用于裁剪流为指定数量的项目                                   |
| XINFO      | 这个命令用于返回stream和相关消费者组的不同信息。它有三种形式<br/>XINFO STREAM<br/>这个命令返回stream的通用信息<br/>XINFO GROUPS<br/>这个命令用于获得stream相关的消费者组的信息<br/>XINFO CONSUMERS<br/>这个命令返回指定消费者组的消费者列表 |
| XCLAIM     | 改变pending消息的所有权，新的owner是命令参数中的consumer     |
| XACK       | 用于删除消费者组的pending entries list中的元素               |

##### 场景

消息队列